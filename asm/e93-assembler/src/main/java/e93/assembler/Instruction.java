package e93.assembler;

import javax.annotation.Generated;

/**
 * Simple data structure for an Instruction. All of the instructions in the
 * instruction set are modeled with this class.
 *
 * Note that not all instructions will have all of the fields populated.
 *
 * Also note that this assumes a two register instruction format only. If you have
 * a three register format then you should expand this.
 *
 *
 * @author markford
 */
public class Instruction {
    /**
     * The address (or value of the PC) of the instruction is set by the assembler.
     * This should be done at a point where you're sure that the instruction
     * won't change. For example, if it's a pseudo instruction, it may
     * generate 2 or 3 other instructions that take its place and would therefore
     * shift the addresses of all of the other instructions.
     *
     * The address may be used when encoding an instruction.
     */
    private int address;

    /**
     * The OpCode for the instructions. All instructions have OpCodes.
     */
    private OpCode opcode;

    /**
     * Some instructions have a value for the first register. This may be rd, rs,
     * or rt depending on your instruction set.
     */
    private int r1;

    /**
     * Some instructions have a value for the second register. This may be rd, rs,
     * or rt depending on your instruction set.
     */
    private int r2;

    /**
     * Some instructions have an immediate value.
     */
    private int immediate;

    /**
     * Some instructions have a function code. This is a good technique to pack
     * more behavior into an instruction set. For example, all of the ALU related
     * instructions could have the same opcode value but then use a few bits
     * in the instruction to differentiate between them.
     */
    private int func;

    /**
     * Some instructions have a label. This is a reference to some other instruction
     * that they're jumping or branching to.
     *
     * In cases where the assembly programmer used a label in their instruction,
     * the Assembler is responsible for replacing this label reference with the
     * correct immediate. The way this is done is outlined in the principles of
     * operation document for your instruction set.
     *
     * For example, when handling a branch instruction, the assembler may take
     * address of the label and compute the difference between it and PC + 2.
     * When handling a jump instruction, it may take the address of the label and
     * compute a value for the lower 12 bits that can be OR'd in with the high
     * order bits of PC + 2.
     */
    private String label;

    @Generated("generated by IDE")
    public int getAddress() {
        return address;
    }

    @Generated("generated by IDE")
    public Instruction setAddress(int address) {
        this.address = address;
        return this;
    }

    @Generated("generated by IDE")
    public String getLabel() {
        return label;
    }

    @Generated("generated by IDE")
    public Instruction setLabel(String label) {
        this.label = label;
        return this;
    }

    @Generated("generated by IDE")
    public OpCode getOpcode() {
        return opcode;
    }

    @Generated("generated by IDE")
    public Instruction setOpcode(OpCode opcode) {
        this.opcode = opcode;
        return this;
    }

    @Generated("generated by IDE")
    public int getR1() {
        return r1;
    }

    @Generated("generated by IDE")
    public Instruction setR1(int r1) {
        this.r1 = r1;
        return this;
    }

    @Generated("generated by IDE")
    public int getR2() {
        return r2;
    }

    @Generated("generated by IDE")
    public Instruction setR2(int r2) {
        this.r2 = r2;
        return this;
    }

    @Generated("generated by IDE")
    public int getImmediate() {
        return immediate;
    }

    @Generated("generated by IDE")
    public Instruction setImmediate(int immediate) {
        this.immediate = immediate;
        return this;
    }

    @Generated("generated by IDE")
    public int getFunc() {
        return func;
    }

    @Generated("generated by IDE")
    public Instruction setFunc(int func) {
        this.func = func;
        return this;
    }

    @Override
    @Generated(value = "generated by IDE")
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Instruction that = (Instruction) o;

        if (address != that.address) return false;
        if (opcode != that.opcode) return false;
        if (r1 != that.r1) return false;
        if (r2 != that.r2) return false;
        if (immediate != that.immediate) return false;
        if (func != that.func) return false;
        return label != null ? label.equals(that.label) : that.label == null;

    }

    @Override
    @Generated(value = "generated by IDE")
    public int hashCode() {
        int result = address;
        result = 31 * result + opcode.getValue();
        result = 31 * result + r1;
        result = 31 * result + r2;
        result = 31 * result + immediate;
        result = 31 * result + func;
        result = 31 * result + (label != null ? label.hashCode() : 0);
        return result;
    }
}
