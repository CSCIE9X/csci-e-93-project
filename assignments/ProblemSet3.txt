			    Problem Set 3

		 Harvard Extension School CSCI E-93:
			Computer Architecture

			      Fall 2017

		  Due: October 15, 2017 at Midnight

Total of 200 Points

Please submit your solution to this problem set using "git" with the tag
ps3-submit.

1. (60 Points) VHDL Counter

Produce VHDL code for either the Altera DE2-70 or DE2-115 Development
and Education Board using the Altera Quartus II Web Edition Software,
Version 13.0, Service Pack 1.  Your code will reside in either the
EP2C70F896C6N (DE2-70) (identified in Quartus as EP2C70F896C6) or
EP4CE115F29C7N (DE2-115) (identified in Quartus as EP4CE115F29C7) FPGA
device.  Your VHDL code should implement an 8-bit counter that resets
(to value zero) when pushbutton KEY3 (KEY[3]) is pressed and counts up
by one each time pushbutton KEY2 (KEY[2]) is pressed.  Note that the
pushbuttons are active low (i.e., normally high) and are debounced in
hardware.  The value in the counter should be displayed in the two
leftmost seven-segment LEDs (HEX7 (HEX7_D[*]) and HEX6 (HEX6_D[*])) as
a hexadecimal number.  Note that the LED sements are active low (i.e.,
the segment is illuminated when the corresponding I/O pin is driven
low).

For the DE2-70, KEY3 is connected to FPGA pin PIN_U29 and KEY2 is
connected to FPGA pin PIN_U30.  In the Altera DE2-70 Development and
Education Board User Guide, Version 1.09 (incorrectly labeled in the
document as Version 1.08), Figure 5.7 identifies the scheme for naming
the segments in each display.  In the same document, Table 5.4
identifies the pin assignments for the seven-segment LEDs.

For the DE2-115, KEY3 is connected to FPGA pin PIN_R24 and KEY2 is
connected to FPGA pin PIN_N21.  In the Altera DE2-115 User Manual
(available from the Terasic web site and with copyright dates
2003-2013), Figure 4-10 identifies the scheme for naming the segments
in each display.  In the same document, Table 4-4 identifies the pin
assignments for the seven-segment LEDs.

Your counter should be designed from basic gates -- that is, do not
simply use VHDL's ability to add one to an integer as a way to build a
counter.  For this problem set, start by implementing a full-adder
component.  Use the full-adder to implement an 8-bit adder component.
Implement a component that converts a four-bit vector into a vector
for a seven-segment display.  Implement an 8-bit register with clear
capability.  Use instantiations of these components to build your
top-level entity.

Remember to set "Reserve all unused pins:" to "As input tri-stated"
under Assignments -> Settings... -> Category: Device -> Device and Pin
Options... -> Unused Pins every time you create a new project.  Also,
remember to check all warnings issued by the compiler and also to
assign appropriate pins that are used in the project.

See Altera Software Installation and Licensing Manual for Windows
(http://www.altera.com/literature/manual/quartus_install.pdf) for
information on how to install, configure, and use the Altera software.
The drivers for connecting the DE2-70 over USB are located in the
following directories:
  Windows: <drive>:\altera\<version number>\quartus\drivers
  Linux: <home directory>/altera <version number>/quartus/drivers


2. (25 Points) Katz and Borriello 3.18 (Hazard-Free Design)
		(5 Points per subpart)

3. (30 Points) Katz and Borriello 5.12 (ALU Design)

4. (15 Points) Katz and Borriello 7.4 (Counter Design)
		(5 Points per subpart)

5. (10 Points) Katz and Borriello 7.27 (Word Problem)

6. (10 Points) Katz and Borriello 8.2 (State Reduction)
	    	You should choose a method that will yield some
		reduction.  Please justify your choice of method.

7. (20 Points) Katz and Borriello 8.7 (State Assignment)

8. (30 Points) Final Program in High-level Language

Write a program in C, C++, or Java to perform the following actions.
Write separate procedures, functions, or methods for each of these
operations: (1) input a string using character input operations, (2)
convert a string to a signed integer numeric value in two's-complement
representation representing the same value in decimal and checking
that all characters in the string are digits with a possible preceding
negative-sign (which is the same character as a dash or hyphen) --
this function should indicate if the input string cannot be
successfully be represented as a signed integer numeric value, (3)
take two signed integer numeric values in two's-complement
representation (these are named the multiplicand and the multiplier)
and multiply them to produce a signed integer numeric product in
two's-complement representation (at your option, the product may be
either at the same precision as the multiplicand and the multiplier or
may be in twice the precision of the multiplicand and the multiplier)
-- it is not necessary to detect overflow, (4) convert a signed
integer numeric value in two's-complement representation to a string
representing the same value in decimal (note that this value may be
negative), and (5) output a string using character output operations.
These functions are specified to perform the same way that the
functions required for the final project perform.

The minimum number you need to be able to read is -32768 and the
maximum number you need to be able to read is 32767.  You're welcome
to accept numbers that span a larger range.  The minimum precision for
all signed integer numeric values must be able to represent values
from -32768 to 32767, inclusively.  Note that integer types in C, C++,
and Java on all modern computers use two's-complement representation;
therefore, you are welcome to use "int" as the data type for your
numbers.  Please do *not* create arrays of bits to represent numeric
values.

All input characters are encoded using the ASCII character-encoding
scheme.

None of these functions should use any library methods to perform
their computation.  That is, do not use built-in calls to perform the
string-to-value conversions (or vice versa); this conversion should be
written from scratch.  You are allowed to use library functions for
input/output operations for characters, but not for either strings or
for integers (i.e., fputc(c, stream), putc(c, stream), and putchar(c)
are allowed for output, but fputs(s, stream), puts(s), printf("%s",
s), and printf("%d", i) are *not* allowed; fgetc(stream),
getc(stream), and getchar() are allowed for input, but fgets(s, n,
stream), gets(s), scanf("%s", s), and scanf("%d", &i) are *not*
allowed).  Also, do not use the multiply operator to perform
multiplication.  Your algorithm for multiplication should use an
efficient shifting approach.  None of your code should use a multiply,
divide, remainder, or modulo operator provided by the programming
language.

A main program should exist to call these functions so that: (1) a
prompt is output asking the user to enter a value and that value is
input as a string, (2) a second prompt is output asking the user to
enter a second value and that value is input as a string, (3) the
input strings are converted to integer numeric values and any errors
are output to the user if the strings do not contain strictly decimal
digits, (4) the two input values are multiplied by each other to
produce a product, (5) the product is converted into a string
representing that decimal value, (6) the product string is output
preceded by an appropriate string describing the output.

Your interaction with the main program might look like:

 This program multiplies two signed integers.  Please enter the first number: 3
 Please enter the second number: 4
 The product of 3 and 4 is 12.
 This program multiplies two signed integers.  Please enter the first number:
 
Function/procedure/method declarations might look like:

(1) Input a string using character input operations:

In C:
 /* read one character at a time until you reach a newline.  Assemble the
  *   characters into a null-terminated string.  That is, perform an
  *   operation similar to "char *fgets(char *s, int n, FILE *stream)"
  * sample typed input: "1234\n" or "-77\n"
  * sample output: "1234" or "-77" */
 char *getString(char *string, int stringSize);

In Java:
 // read one character at a time until you reach a newline.  Assemble the
 //   characters into a string.
 // sample typed input: "1234\n" or "-77\n"
 // sample output: ['1', '2', '3', '4'] or ['-', '7', '7']
 byte[] getString(InputStream is);

(2) Convert a string to a signed integer numeric value:

In C:
 /* perform an operation similar to "long strtol(const char *str,
  *   char **endptr, int base)"
  * sample input: "1234"
  * sample output: 1234 */
 int stringToInt(char *value);

In Java:
 // perform an operation similar to "Integer.parseInt(new String(byte))"
 // sample input: ['1,'2','3','4']
 // sample output: 1234
 int stringToInt(byte[] value);

(3) Multiply two signed integer numeric values:

In C:
 /* signed multiplication; don't use the multiplication operator */
 int multiply(int a, int b);

In Java:
 // signed multiplication; don't use the multiplication operator
 int multiply(int a, int b);

(4) Convert a signed integer numeric value in two's-complement
    representation to a string representing the same value in decimal:

In C:
 /* perform an operation similar to "int sprintf(char *s, const char *format,
  *   ...)" with a format string of "%d"
  * sample input: 1234
  * sample output: ['1,'2','3','4','\n'] */
 char *intToString(int value);

In Java:
 // perform an operation similar to "String.valueOf(int)"
 // sample input: 1234
 // sample output: ['1,'2','3','4','\n']
 byte[] intToString(int value);

(5) Output a string using character output operations:

In C:
 /* output a string to stdout.  Perform an operation similar to
  *   "int fputs(const char *s, FILE *stream)"
  * should call "int fputc(int c, FILE *stream)" to perform the output */
 void putString(char *value);

In Java:
 // output a string to stdout.  Perform an operation similar to
 //   "System.out.print()"
 // should call "System.out.print()" to perform the output character by
 //   character
 void putString(byte[] value);


			Last revised 27-Jul-17
