			    Problem Set 2

		 Harvard Extension School CSCI E-93:
			Computer Architecture

			      Fall 2017

		   Due: October 1, 2017 at Midnight

Total of 150 Points

This assignment is the first problem set leading to the creation of
the final project.

Please submit your solution to this problem set using "git" with the tag
ps2-submit.

1. (50 Points) Produce a block diagram for your proposed final
project.  The design may be for any of a number of different types of
architectures: single accumulator, multiple register, stack,
load/store, RISC, CISC, etc.  Your design should be determined by your
background and familiarity, the inherent complexity of the design, the
limited time to implement and debug the design, and the requirements
listed below.

There are many decisions that need to be made to arrive at a final
design.  What is the basic word size of your design?  How many
registers are made available to the assembler programmer?  Which
instuctions are able to access data in memory?  Does your design allow
the PC to be accessed by the user as one of the general purpose
registers?  Does your design have condition codes or do those
instructions that would otherwise have a result expressed in condition
codes directly reflect that result either in a conditional branch
(like the MIPS conditional branch instructions) or a numeric result
(like the MIPS set-on-... instructions)?  Are all registers general
purpose or do some have special functionality?  Are there special
instuctions to access the stack or is this done through regular
instructions?  Is there a PSW (processor status word) and, if so, what
state is maintained in the PSW?  Does the instruction set include
shift instructions?  Does the instruction set include rotate
instructions?  Which of the many arithmetic and logical shift/rotate
variations are going to be implemented?  Do the shift and/or rotate
instructions move the data a single bit or allow multiple bit
movement?  If multiple bit shifts and/or rotates are allowed, is the
shift/rotate bit distance specified in the instruction (a fixed
immediate value) or in a register (a variable distance that can be
different each time the instruction is executed)?

Each design should include at least one novel feature.  Suggestions
include memory protection, barrel shifter, privileged execution modes,
virtual memory, caching, pipelining, hardware multiplier, supervisor
call instruction, hardware interrupt mechanism, and floating point.
Feel free to consult with either your TA or the professor to discuss
the novel features.  In your proposal, the novel feature should be
carefully described.  Once again, choose a new feature that sparks
your interest and is based on your background.

The block diagram should indicate all functional units (registers --
both those accessible to the assembly language programmer (such as
general purpose registers) and those not accessible (such as the IR,
PC, PSW), ALUs, multiplexers, the sequencer), all data paths and their
widths, all status lines (e.g. zero, negative, carry out, overflow),
and all control lines.  Components that accept function codes need
documentation to describe the encoding of those function codes into
specific actions.  For example, an ALU would need to have a table
that describes how the ALU function code value is mapped into specific
ALU actions.

Your project will have access to I/O devices through a memory-mapped
interface.  That is, if you can read and write bytes and test bits in
some control register in a special memory location, you will be able
to perform I/O to a virtual terminal.

In addition, each design must include a mechanism to allow subroutines
to be called and for the subroutine to return to the instruction
following the calling instruction.

Requirements: (1) Your computer must be able to address at least 64K
bytes of memory, but you will be supplied with 2M bytes of memory (the
memory can be accessed as bytes, as 16-bit quantities (henceforth
referred to as a word), or as 32-bit longwords in little endian order;
the size of an access is determined by a control flag sent to the
memory), (2) your computer must be able to read and write
variable-length strings to and from a virtual terminal, (3) your
computer must be able to convert from two bytes (i.e., a word) in
two's-complement notation in memory into a string of ASCII characters
representing that word's decimal value and vice versa, (4) your
computer must be able to multiply two two's-complement words to
produce at least a single two's-complement word product, (5) your
computer must be able to prompt the user to enter two integers, accept
those two integers, multiply them together, and print out the product.
You are welcome to implement extended precision (for example, to
multiply two words to produce a doubleword product or to multiply two
doublewords to produce either a doubleword or a quadword product), but
that is not required.

The memory interface allows the memory to be read and written as
either 8-bit bytes, 16-bit words, or 32-bit doublewords.  Although
many projects allow access to the memory as either bytes or words (or
sometimes even doublewords) depending on the word size of the
processor and on the particular instruction, it is possible to create
a successful project that is able to access memory only as either
bytes, words, or doublewords.


2. (100 Points) Produce a design for the instruction set for the
computer whose block diagram is in Problem 1 above.  The instruction
set should include all instructions to be implemented.  For each
instruction show the specific opcode and operands, including possible
addressing modes and other variants.  This documentation should
include the encoding of the opcode, operands, and any addressing modes
into specific bit fields in the machine code instruction word.  Give
each of your instructions a name and design an assembler language for
your computer.  Include concise documentation of the assembler
language (the documentation should be sufficient for a seasoned
assembler language programmer to understand and be able to write
programs for your computer).


			Last revised 27-Jul-17
